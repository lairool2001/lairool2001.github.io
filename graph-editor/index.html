<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="content-language" content="zh-tw">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <title>圖型編輯器</title>
    <style type="text/css">
        #div_left {
            width: 300px;
            min-height: 90vh;
            background-color: antiquewhite;
            float: left;
        }

        #div_right {
            padding: 0px;
            margin: 0px;
            background-color: aquamarine;
            float: left;
        }

        #t1 {
            left: 100px;
            top: 50px;
            margin: 0px;
            padding: 0px;
            min-width: 200px;
            min-height: 400px;
        }

        #svg1 {
            border: 1px double black;
        }

        .rect1_text {
            text-anchor: middle;
            font-size: 20px;
            font-family: 微軟正黑體;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -o-user-select: none;
        }

    </style>
</head>

<body onkeydown="body_onkeydown(event);">
    <div id="div_left">
        <button onclick="create_onclick(this,event);">create block</button>
        <p>Load:<input type="file" id="file1" onchange="onChange(event);"></p>
        <textarea id="t1"></textarea>
        <br />
        <br />
        <button onclick="save_onclick(this,event);">save</button>
    </div>
    <div id="div_right">
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" id="svg1" width="900" height="800" onmousedown="svg_onMouseDown(event)" onContextMenu="return false" viewBox="0 0 900 800" onMouseUp="onMouseUp(event);"></svg>
    </div>
    <script>
        drag = false;
        select_rect = null;
        select_text = null;
        connect1_rect = null;
        connect1_text = null;
        connect2_rect = null;
        connect2_text = null;
        flow_id_block = 0;
        flow_id_line = 0;
        blockz = [];
        blockById = {};
        connect = 0;
        ab = {};
        svg1.onmousemove = on_mouse_move;

        console.log(svg1.viewBox);
        addABlock();
        addABlock();

        check_blockById();

        function check_blockById() {
            for (i = 0; i < blockz.length; i++) {
                var a = document.getElementById(`rect` + i);
                console.log(blockById[a.id]);
            }
        }

        function body_onkeydown(event) {
            var power = 10;
            console.log(svg1.viewBox);
            console.log(event.keyCode);

            xMin = svg1.viewBox.animVal.x;
            yMin = svg1.viewBox.animVal.y;
            width = svg1.viewBox.animVal.width;
            height = svg1.viewBox.animVal.height;
            switch (event.keyCode) {
                case 87:
                    //w
                    yMin -= power;
                    break;
                case 83:
                    //s
                    yMin += power;
                    break;
                case 65:
                    //a
                    xMin -= power;
                    break;
                case 68:
                    //d
                    xMin += power;
                    break;
                case 46:
                    //del
                    if (previous_select_rect != null) {
                        let block = getBlock(previous_select_rect);
                        for (let i = 0; i < block.linezId.length; i++) {
                            let l = document.getElementById(block.linezId[i]);
                            if (l == null) {
                                block.linezId.splice(i, 1);
                                i--;
                                continue;
                            }
                            svg1.removeChild(l);
                        }
                        svg1.removeChild(document.getElementById(block.textId));
                        svg1.removeChild(previous_select_rect);
                        console.log("del");
                        previous_select_rect = null;
                    }
                    break;
            }
            viewBox = `${xMin} ${yMin} ${width} ${height}`;
            svg1.setAttribute('viewBox', viewBox)
        }

        function onChange(e) {
            file = e.target.files[0];
            file.text().then(a => {
                text = a;
                console.log(text);
                //console.log(e.target.files[0]);
                var data = JSON.parse(text);
                console.log(data);
                flow_id_block = data.flow_id_block;
                flow_id_line = data.flow_id_line;
                blockz = data.blockz;
                ab = data.ab;
                //data.blockById = blockById;
                //rebuild blockById
                blockById = data.blockById;
                blockz = data.blockz;
                div_right.innerHTML = data.innerHTML;
                for (let i = 0; i < flow_id_block; i++) {
                    e = document.getElementById('rect' + i);
                    blockz[i] = blockById[e.id] = getBlock(e);
                    console.log(e);
                }
                check_blockById();
                svg1.onmousemove = on_mouse_move;
                console.log("load completed");
            });
        }

        function save_onclick(button, event) {
            var data = {};
            data.flow_id_block = flow_id_block;
            data.flow_id_line = flow_id_line;
            data.ab = ab;
            data.blockById = blockById;
            data.blockz = blockz;
            data.innerHTML = div_right.innerHTML;

            str = JSON.stringify(data);
            saveTextAsFile("123.txt", str);
            console.log('a')
        }

        function saveTextAsFile(_fileName, _text) {
            var textFileAsBlob = new Blob([_text], {
                type: 'text/plain'
            });

            var downloadLink = document.createElement("a");
            downloadLink.download = _fileName;
            downloadLink.innerHTML = "Download File";
            if (window.webkitURL != null) {
                // Chrome allows the link to be clicked
                // without actually adding it to the DOM.
                downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
            } else {
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                downloadLink.onclick = destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }

            downloadLink.click();
        }

        function destroyClickedElement(event) {
            document.body.removeChild(event.target);
        }

        function load_onclick(button, event) {

        }

        function svg_onMouseDown(event) {
            drag = true;
        }

        function create_onclick(button, event) {
            b = addABlock();
            console.log(svg1.width.animVal.value);
            x = svg1.viewBox.animVal.x;
            y = svg1.viewBox.animVal.y;
            width = svg1.viewBox.animVal.width;
            height = svg1.viewBox.animVal.height;
            r = document.getElementById(b.rectId);
            r.setAttributeNS(null, 'x', width / 2 + x);
            r.setAttributeNS(null, 'y', height / 2 + y);
            updateBlock(b);
        }

        function onMouseUp() {
            drag = false;
            previous_select_rect = select_rect;
            select_rect = null;
            select_text = null;
            //console.log("onMouseUp()");
        }

        function updateBlock(b) {
            set_text_in_rect(b.textId, b.rectId);
        }

        function addABlock() {
            svg1.innerHTML += `<rect x="100" y="50" z="1" width="40" height="40" stroke="black" stroke-width="2" fill="red" onmousedown="mouse_down(event,this);" id="rect` + flow_id_block + `"></rect>
            <text x="100" y="50" z="1" onselectstart="return false;" unselectable id="rect` + flow_id_block + `_text" class="rect1_text" onmousedown="mouse_down(event,rect` + flow_id_block + `);">123</text>`;
            r = document.getElementById(`rect` + flow_id_block);
            t = document.getElementById("rect" + flow_id_block + "_text");
            //console.log(r);
            //console.log(t);
            b = {};
            b.rectId = r.id;
            b.textId = t.id;
            b.linezId = [];
            b.id = r.id;
            console.log(b.id);
            blockz.push(b);
            blockById[r.id] = b;
            //r.setAttributeNS(null, 'block', JSON.stringify(b));
            //console.log(r.block);
            set_text_in_rect(t.id, r.id);
            flow_id_block += 1;
            return b;
        }

        function addALine(x1, y1, x2, y2) {
            svg1.innerHTML = `<line x1="` + x1 + `" y1="` + y1 + `" x2="` + x2 + `" y2="` + y2 + `" z="2" style="stroke: Tomato;stroke-width: 3px" id="line` + flow_id_line + `"/>` + svg1.innerHTML;
            var l = document.getElementById("line" + flow_id_line);
            flow_id_line += 1;
            ab[l.id] = {};
            return l;
        }

        function getAB(l) {
            return ab[l.id];
        }
        //console.log(div_right.offsetLeft);

        function on_mouse_move(event) {
            mouse_event = event;

            //拖拉方塊
            if (select_rect != null && drag) {
                let startViewBox = svg1.getAttribute('viewBox').split(' ').map(n => parseFloat(n))
                let startClient = {
                    x: event.clientX,
                    y: event.clientY
                }
                let newSVGPoint = svg1.createSVGPoint()
                let CTM = svg1.getScreenCTM()
                newSVGPoint.x = startClient.x
                newSVGPoint.y = startClient.y
                let startSVGPoint = newSVGPoint.matrixTransform(CTM.inverse())

                x = svg1.viewBox.animVal.x;
                y = svg1.viewBox.animVal.y;
                select_rect = document.getElementById(select_rect.id);
                select_rect.setAttributeNS(null, 'x', startSVGPoint.x + dx)
                select_rect.setAttributeNS(null, 'y', startSVGPoint.y + dy)
                //select_rect.setAttributeNS(null, 'x', event.clientX - div_right.offsetLeft);
                //select_rect.setAttributeNS(null, 'y', event.clientY - div_right.offsetTop);
                set_text_in_rect(select_text.id, select_rect.id);
                b = blockById[select_rect.id];
                //select_rect.block = b;
                if (!b) {
                    console.log("error");
                }
                updateBlockLine(b);
            }
            //移動畫布
            else if (select_rect == null && drag) {
                let startViewBox = svg1.getAttribute('viewBox').split(' ').map(n => parseFloat(n))

                //	2. 取得滑鼠當前 viewport 中 client 座標值
                let startClient = {
                    x: event.clientX,
                    y: event.clientY
                }

                //	3. 計算對應回去的 SVG 座標值
                let newSVGPoint = svg1.createSVGPoint()
                let CTM = svg1.getScreenCTM()
                newSVGPoint.x = startClient.x
                newSVGPoint.y = startClient.y
                let startSVGPoint = newSVGPoint.matrixTransform(CTM.inverse())

                //	4. 計算拖曳後滑鼠所在的 viewport client 座標值
                let moveToClient = {
                    x: event.clientX + event.movementX, //	movement 可以取得滑鼠位移量
                    y: event.clientY + event.movementY
                }

                //	5. 計算對應回去的 SVG 座標值
                newSVGPoint = svg1.createSVGPoint()
                CTM = svg1.getScreenCTM()
                newSVGPoint.x = moveToClient.x
                newSVGPoint.y = moveToClient.y
                let moveToSVGPoint = newSVGPoint.matrixTransform(CTM.inverse())

                //	6. 計算位移量
                let delta = {
                    dx: startSVGPoint.x - moveToSVGPoint.x,
                    dy: startSVGPoint.y - moveToSVGPoint.y
                }

                //	7. 設定新的 viewBox 值
                let moveToViewBox = `${startViewBox[0] + delta.dx} ${startViewBox[1] + delta.dy} ${startViewBox[2]} ${startViewBox[3]}`
                svg1.setAttribute('viewBox', moveToViewBox)
                console.log(moveToViewBox)
            }
            //console.log(select_rect);
        }

        function getMiddle(rect) {
            var p = {};
            p.x = parseFloat(rect.getAttributeNS(null, 'x')) + (parseFloat(rect.getAttributeNS(null, 'width')) / 2);
            p.y = parseFloat(rect.getAttributeNS(null, 'y')) + (parseFloat(rect.getAttributeNS(null, 'height')) / 2);
            return p;
        }

        function updateBlockLine(block) {
            //console.log(block.linez);
            var be = document.getElementById(block.rectId);
            p = getMiddle(be);
            for (let i = 0; i < block.linezId.length; i++) {
                l = document.getElementById(block.linezId[i]);
                //l = document.getElementById(l.id);
                if (l == null) {
                    block.linezId.splice(i, 1);
                    i--;
                    continue;
                }
                var k = getAB(l);
                console.log(k.aBlock.id);
                console.log(k.bBlock.id);
                console.log(block.id);
                if (k.aBlock.id == block.id) {
                    //console.log("a");
                    l.setAttributeNS(null, 'x1', p.x);
                    l.setAttributeNS(null, 'y1', p.y);

                } else if (k.bBlock.id == block.id) {
                    //console.log("b");
                    //console.log("b");
                    l.setAttributeNS(null, 'x2', p.x);
                    l.setAttributeNS(null, 'y2', p.y);
                } else {
                    console.log("err");
                }
                //console.log(p.x);
            }
        }

        function getBlock(r) {
            return blockById[r.id];
            //return JSON.parse(r.getAttributeNS(null, 'block'));
        }

        function mouse_down(event, s) {
            //console.log("c1_click");
            //console.log(event);
            drag = !drag;
            //連線
            if (event.button == 2) {
                if (connect == 0) {
                    connect = 1;
                    connect1_rect = s;
                    //console.log(s.block);
                    connect1_text = et = document.getElementById(s.id + "_text");
                } else if (connect == 1) {
                    connect = 0;
                    connect2_rect = s;
                    //console.log(s.block);
                    connect2_text = et = document.getElementById(s.id + "_text");
                    p1 = getMiddle(connect1_rect);
                    p2 = getMiddle(connect2_rect);
                    //console.log(p1);
                    var l = addALine(p1.x, p1.y, p2.x, p2.y);
                    ab[l.id].aBlock = getBlock(connect1_rect);
                    if (!ab[l.id].aBlock) {
                        console.log("err");
                    }
                    ab[l.id].bBlock = getBlock(connect2_rect);
                    if (!ab[l.id].bBlock) {
                        console.log("err");
                    }
                    //l.a = connect1_rect.block;
                    //l.b = connect2_rect.block;
                    b1 = getBlock(connect1_rect);
                    b2 = getBlock(connect2_rect);
                    console.log(b1);
                    console.log(b2);
                    b1.linezId.push(l.id);
                    b2.linezId.push(l.id);
                    //connect1_rect.block.connectz.push(connect2_rect.block);
                    //connect2_rect.block.connectz.push(connect1_rect.block);

                    console.log('connect');
                }
            }
            //拖拉方塊開始
            if (drag && event.button == 0) {
                if (s.tagName == "text") {
                    s = s.block.rect;
                    console.log("text");
                } else if (s.tagName == "rect") {
                    console.log("rect");
                }
                select_rect = s;
                select_text = et = document.getElementById(s.id + "_text");
                t1.value = et.innerHTML;
                t1.oninput = function() {
                    et.innerHTML = t1.value;
                    //console.log(et.innerHTML);
                    set_text_in_rect(et.id, s.id);
                    updateBlockLine(getBlock(s));
                    //t1.style.left = s.getBoundingClientRect().left + 'px';
                    //console.log(s.getBoundingClientRect());
                    //console.log(s.width.animVal.value);
                };
                let startClient = {
                    x: event.clientX,
                    y: event.clientY
                }
                let newSVGPoint = svg1.createSVGPoint()
                let CTM = svg1.getScreenCTM()
                newSVGPoint.x = startClient.x
                newSVGPoint.y = startClient.y
                let startSVGPoint = newSVGPoint.matrixTransform(CTM.inverse())
                console.log(select_rect.x);
                dx = select_rect.x.animVal.value - startSVGPoint.x;
                dy = select_rect.y.animVal.value - startSVGPoint.y;
                on_mouse_move(event);
            } else {}
            return false;
        }

        function set_text_in_rect(textId, rId) {
            //console.log(text.x);
            //console.log(text.y);
            text = document.getElementById(textId);
            r1 = document.getElementById(rId);
            size = textSize("20px", "微軟正黑體", escape(text.innerHTML));
            w = size.width + 30;
            if (w == 0) {
                w = 10;
            }
            h = size.height;
            if (h == 0) {
                h = 10;
            }
            r1.setAttributeNS(null, 'width', w);
            r1.setAttributeNS(null, 'hight', h);
            text.setAttributeNS(null, 'x', parseFloat(r1.getAttributeNS(null, 'x')) + parseFloat(r1.getAttributeNS(null, 'width')) / 2);
            text.setAttributeNS(null, 'y', parseFloat(r1.getAttributeNS(null, 'y')) + parseFloat(r1.getAttributeNS(null, 'height')) / 2 + 7);
            //console.log(text.innerHTML.length);
            //console.log(text.y);
        }
        /*
版权声明：本文为CSDN博主「zy1281539626」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zy1281539626/article/details/78489279
        */

        function textSize(fontSize, fontFamily, text) {
            var span = document.createElement("span");
            var result = {};
            result.width = span.offsetWidth;
            result.height = span.offsetHeight;
            span.style.visibility = "hidden";
            span.style.fontSize = fontSize;
            span.style.fontFamily = fontFamily;
            span.style.display = "inline-block";
            document.body.appendChild(span);
            if (typeof span.textContent != "undefined") {
                span.textContent = text;
            } else {
                span.innerText = text;
            }
            result.width = parseFloat(window.getComputedStyle(span).width) - result.width;
            result.height = parseFloat(window.getComputedStyle(span).height) - result.height;
            document.body.removeChild(span);
            return result;
        }

        function escape(s) {
            return s.replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/'/g, "&#39;")
                .replace(/"/g, "&quot;");
        }

    </script>
</body>

</html>
